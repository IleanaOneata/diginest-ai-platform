---
/**
 * Chat Simulator Component
 *
 * Un mini-chat pre-programat care demonstrează capabilitățile unui agent AI.
 * Scopul: Vizitatorii văd valoarea în primele 5 secunde.
 *
 * Funcționare:
 * - Auto-play la încărcare (cu delay)
 * - Mesaje pre-definite care se "scriu" progresiv
 * - Vizitatorii pot da click pentru a accelera/sări
 * - Ending cu CTA relevant
 */

interface Props {
  locale?: 'ro' | 'en';
  autoPlay?: boolean;
  className?: string;
}

const { locale = 'ro', autoPlay = true, className = '' } = Astro.props;

// Conversații pre-definite
const conversations = {
  ro: [
    { role: 'user', message: 'Bună! Am o comandă #4521, când ajunge?' },
    { role: 'agent', message: 'Bună! Am verificat comanda #4521. Coletul tău este în drum și va ajunge mâine între 14:00-18:00. Vrei să îți trimit un link de tracking?' },
    { role: 'user', message: 'Da, te rog!' },
    { role: 'agent', message: 'Gata! Ți-am trimis link-ul pe email. Mai pot să te ajut cu ceva?' },
  ],
  en: [
    { role: 'user', message: 'Hi! I have order #4521, when will it arrive?' },
    { role: 'agent', message: 'Hi! I checked order #4521. Your package is on its way and will arrive tomorrow between 2-6 PM. Want me to send you a tracking link?' },
    { role: 'user', message: 'Yes please!' },
    { role: 'agent', message: 'Done! I sent the link to your email. Is there anything else I can help with?' },
  ],
};

const messages = conversations[locale] || conversations.ro;

const labels = {
  ro: {
    agentName: 'Agent AI',
    customerName: 'Client',
    typing: 'scrie...',
    responseTime: 'Timp răspuns: 0.8s',
    poweredBy: 'Powered by GENERATIVA',
  },
  en: {
    agentName: 'AI Agent',
    customerName: 'Customer',
    typing: 'typing...',
    responseTime: 'Response time: 0.8s',
    poweredBy: 'Powered by GENERATIVA',
  },
};

const t = labels[locale] || labels.ro;
---

<div class:list={["chat-simulator", className]} data-autoplay={autoPlay}>
  <!-- Chat Window -->
  <div class="bg-white rounded-2xl shadow-xl border border-neutral-200 overflow-hidden max-w-md w-full">
    <!-- Header -->
    <div class="bg-gradient-to-r from-primary-400 to-accent-600 px-4 py-3 flex items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center">
          <svg class="w-6 h-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
          </svg>
        </div>
        <div>
          <div class="text-white font-semibold text-sm">{t.agentName}</div>
          <div class="flex items-center gap-1.5">
            <span class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>
            <span class="text-white/80 text-xs">Online</span>
          </div>
        </div>
      </div>
      <div class="text-white/60 text-xs">{t.responseTime}</div>
    </div>

    <!-- Messages Area -->
    <div class="h-72 overflow-y-auto p-4 space-y-4 bg-neutral-50" id="chat-messages">
      {messages.map((msg, index) => (
        <div
          class={`chat-message opacity-0 transform translate-y-4 transition-all duration-500 flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
          data-index={index}
          data-role={msg.role}
        >
          <div class={`max-w-[80%] ${msg.role === 'user' ? 'order-2' : 'order-1'}`}>
            <div class={`text-xs mb-1 ${msg.role === 'user' ? 'text-right text-neutral-500' : 'text-left text-primary-600'}`}>
              {msg.role === 'user' ? t.customerName : t.agentName}
            </div>
            <div class={`px-4 py-2.5 rounded-2xl text-sm leading-relaxed ${
              msg.role === 'user'
                ? 'bg-primary-500 text-white rounded-br-md'
                : 'bg-white text-neutral-800 shadow-sm border border-neutral-100 rounded-bl-md'
            }`}>
              <span class="message-text"></span>
              <span class="typing-cursor">|</span>
            </div>
          </div>
        </div>
      ))}

      <!-- Typing Indicator (hidden by default) -->
      <div id="typing-indicator" class="hidden flex justify-start">
        <div class="bg-white px-4 py-3 rounded-2xl rounded-bl-md shadow-sm border border-neutral-100">
          <div class="flex gap-1">
            <span class="w-2 h-2 bg-neutral-400 rounded-full animate-bounce" style="animation-delay: 0ms"></span>
            <span class="w-2 h-2 bg-neutral-400 rounded-full animate-bounce" style="animation-delay: 150ms"></span>
            <span class="w-2 h-2 bg-neutral-400 rounded-full animate-bounce" style="animation-delay: 300ms"></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Footer -->
    <div class="px-4 py-3 bg-white border-t border-neutral-100 flex items-center justify-between">
      <span class="text-xs text-neutral-400">{t.poweredBy}</span>
      <button
        id="replay-btn"
        class="text-xs text-primary-500 hover:text-primary-600 font-medium opacity-0 transition-opacity"
      >
        Replay
      </button>
    </div>
  </div>
</div>

<script define:vars={{ messages }}>
  document.addEventListener('DOMContentLoaded', () => {
    const simulator = document.querySelector('.chat-simulator');
    if (!simulator) return;

    const autoPlay = simulator.dataset.autoplay === 'true';
    const messageElements = document.querySelectorAll('.chat-message');
    const typingIndicator = document.getElementById('typing-indicator');
    const replayBtn = document.getElementById('replay-btn');
    const messagesContainer = document.getElementById('chat-messages');

    let currentIndex = 0;
    let isPlaying = false;

    const typeMessage = (element, text, callback) => {
      const textSpan = element.querySelector('.message-text');
      const cursor = element.querySelector('.typing-cursor');
      let charIndex = 0;

      cursor.style.opacity = '1';

      const typeChar = () => {
        if (charIndex < text.length) {
          textSpan.textContent += text[charIndex];
          charIndex++;
          setTimeout(typeChar, 30 + Math.random() * 20);
        } else {
          cursor.style.opacity = '0';
          if (callback) setTimeout(callback, 300);
        }
      };

      typeChar();
    };

    const showMessage = (index) => {
      if (index >= messageElements.length) {
        isPlaying = false;
        replayBtn.style.opacity = '1';
        return;
      }

      const element = messageElements[index];
      const role = element.dataset.role;
      const text = messages[index].message;

      // Show typing indicator for agent messages
      if (role === 'agent') {
        typingIndicator.classList.remove('hidden');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        setTimeout(() => {
          typingIndicator.classList.add('hidden');
          element.classList.remove('opacity-0', 'translate-y-4');
          typeMessage(element, text, () => {
            currentIndex++;
            setTimeout(() => showMessage(currentIndex), 800);
          });
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }, 1000 + Math.random() * 500);
      } else {
        // User messages appear instantly
        element.classList.remove('opacity-0', 'translate-y-4');
        typeMessage(element, text, () => {
          currentIndex++;
          setTimeout(() => showMessage(currentIndex), 500);
        });
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
    };

    const startSimulation = () => {
      if (isPlaying) return;

      isPlaying = true;
      currentIndex = 0;
      replayBtn.style.opacity = '0';

      // Reset all messages
      messageElements.forEach(el => {
        el.classList.add('opacity-0', 'translate-y-4');
        el.querySelector('.message-text').textContent = '';
        el.querySelector('.typing-cursor').style.opacity = '0';
      });

      setTimeout(() => showMessage(0), 500);
    };

    // Replay button
    replayBtn.addEventListener('click', startSimulation);

    // Auto-start when in viewport
    if (autoPlay) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !isPlaying) {
            startSimulation();
            observer.disconnect();
          }
        });
      }, { threshold: 0.5 });

      observer.observe(simulator);
    }
  });
</script>

<style>
  .typing-cursor {
    animation: blink 0.7s infinite;
    opacity: 0;
  }

  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
</style>
